// Generated by CoffeeScript 2.0.0-beta5
void function () {
  var async, axilla, cacheFunction, cachePartial, cacheTemplate, fs, glob, isAbsolutePath, isPartial, Mustache, partials, Path, readFileSync, removeBaseDir, render, stripPath, templates, utils;
  fs = require('fs');
  Path = require('path');
  glob = require('glob');
  async = require('async');
  Mustache = require('mustache');
  module.exports = axilla = function (basePath, defaults) {
    if (utils.isObject(basePath)) {
      defaults = basePath;
      basePath = null;
    }
    return function (path, viewObject, options) {
      if (!utils.isEmpty(basePath))
        path = Path.normalize('' + basePath + path.sep + path);
      return render(path, viewObject, utils.defaults(options, defaults));
    };
  };
  axilla.templates = templates = {};
  axilla.partials = partials = {};
  axilla.render = render = function (path, viewObject, options) {
    var template;
    if (null == options)
      options = {};
    if (null != templates[path])
      return templates[path](viewObject);
    if (!(fs.existsSync(path) && fs.statSync(path).isFile()))
      throw new Error('Unable to resolve file at ' + path);
    template = readFileSync(path);
    return Mustache.render(template, viewObject);
  };
  axilla.cache = function (options, cb) {
    var baseDir;
    baseDir = utils.isString(options) ? options : options.baseDir;
    if (!isAbsolutePath(baseDir))
      baseDir = Path.normalize('' + __dirname + Path.sep + baseDir);
    glob(Path.normalize('' + baseDir + '/**/*.mustache'), function (err, paths) {
      var iterator;
      console.log(Path.normalize('' + baseDir + '/**/*.mustache'), paths);
      iterator = function (path, cb) {
        return cacheTemplate([
          path,
          removeBaseDir(baseDir, path)
        ], options, cb);
      };
      return async.each(paths, iterator, function (err) {
        if (null != cb)
          return cb(err);
        if (null != err)
          throw err;
      });
    });
    return null;
  };
  axilla.clearCache = function () {
    axilla.templates = templates = {};
    return axilla.partials = partials = {};
  };
  cacheTemplate = function (paths, options, cb) {
    var absolute, cache$, relative;
    cache$ = paths;
    absolute = cache$[0];
    relative = cache$[1];
    return fs.readFile(absolute, 'utf8', function (err, contents) {
      var base;
      if (null != err)
        return cb(err);
      base = stripPath(relative);
      if (isPartial(Path.basename(relative))) {
        cachePartial(base, contents);
      } else {
        cacheFunction(base, contents);
      }
      return cb();
    });
  };
  cacheFunction = function (path, template) {
    return templates[path] = function (viewObject) {
      return Mustache.render(template, viewObject, partials);
    };
  };
  cachePartial = function (path, blah) {
    return partials[path] = blah;
  };
  removeBaseDir = function (baseDir, path) {
    return path.split(new RegExp('^' + baseDir + '/'))[1];
  };
  stripPath = function (path) {
    var base, filename;
    filename = Path.basename(path);
    base = filename.split('.')[0];
    if (isPartial(base))
      base = base.split(/^_/)[1];
    return '' + path.split(filename)[0] + base;
  };
  isPartial = function (filename) {
    return null != filename.match(/^_/);
  };
  isAbsolutePath = function (path) {
    return null != path.match(new RegExp('^' + Path.sep));
  };
  readFileSync = function (filename, options) {
    if (null == options)
      options = {};
    return fs.readFileSync(filename, utils.defaults(options, { encoding: 'utf8' }));
  };
  utils = function () {
    var slice, toString;
    slice = Array.prototype.slice;
    toString = Object.prototype.toString;
    return {
      extend: function (obj) {
        slice.call(arguments, 1).forEach(function (source) {
          var key;
          for (key in source) {
            if (!isOwn$(source, key))
              continue;
            obj[key] = source[key];
          }
          return void 0;
        });
        return obj;
      },
      defaults: function (obj) {
        slice.call(arguments, 1).forEach(function (source) {
          var key;
          for (key in source) {
            if (!isOwn$(source, key))
              continue;
            if (!(null != obj[key]))
              obj[key] = source[key];
          }
          return void 0;
        });
        return obj;
      },
      isArray: Array.isArray,
      isObject: function (object) {
        return object === Object(object);
      },
      isString: function (object) {
        return toString.call(object) === '[object String]';
      },
      isEmpty: function (object) {
        var key;
        if (!(null != object))
          return true;
        if (utils.isArray(object) || utils.isString(object))
          return object.length === 0;
        for (key in object) {
          if (!isOwn$(object, key))
            continue;
          return false;
        }
        return true;
      }
    };
  }();
  function isOwn$(o, p) {
    return {}.hasOwnProperty.call(o, p);
  }
}.call(this);
