// Generated by CoffeeScript 2.0.0-beta5
void function () {
  var async, axilla, cacheTemplate, fs, glob, Handlebars, isAbsolutePath, isPartial, partials, Path, readAndCompileSync, readFileSync, removeBaseDir, render, renderPartial, stripPath, templates, utils;
  fs = require('fs');
  Path = require('path');
  glob = require('glob');
  async = require('async');
  Handlebars = require('handlebars');
  templates = {};
  partials = {};
  module.exports = axilla = function (basePath, defaults) {
    if (utils.isObject(basePath)) {
      defaults = basePath;
      basePath = null;
    }
    return function (path, viewObject, options) {
      if (!utils.isEmpty(basePath))
        path = Path.normalize('' + basePath + Path.sep + path);
      return render(path, viewObject, utils.defaults(options, defaults));
    };
  };
  axilla.Handlebars = Handlebars;
  Handlebars.registerHelper('partial', function (path) {
    return renderPartial(path, this);
  });
  axilla.render = render = function (path, viewObject) {
    var template;
    if (!(null != (template = templates[path])))
      throw new Error('Unable to resolve template at ' + path);
    return template.render(viewObject);
  };
  axilla.renderPartial = renderPartial = function (path, viewObject) {
    var partial;
    if (!(null != (partial = partials[path])))
      throw new Error('Unable to resolve partial at ' + path);
    return partial.render(viewObject);
  };
  axilla.configure = function (options, cb) {
    var baseDir, cache$;
    if (utils.isString(options)) {
      baseDir = options;
      options = {};
    } else {
      cache$ = options;
      baseDir = cache$.baseDir;
      cache$;
    }
    if (!isAbsolutePath(baseDir))
      throw new Error('Path to baseDir is not an absolute path');
    glob(Path.normalize('' + baseDir + '/**/*.mustache'), function (err, paths) {
      var iterator;
      iterator = function (absolutePath, cb) {
        var base, relativePath;
        relativePath = removeBaseDir(baseDir, absolutePath);
        base = stripPath(relativePath);
        options.isPartial = isPartial(Path.basename(relativePath));
        return cacheTemplate([
          base,
          absolutePath
        ], options, cb);
      };
      return async.each(paths, iterator, function (err) {
        if (null != cb)
          return cb(err);
        if (null != err)
          throw err;
      });
    });
    return null;
  };
  axilla.clearCache = function () {
    templates = {};
    return partials = {};
  };
  cacheTemplate = function (paths, options, cb) {
    var absolute, cache$, relative, templateCache;
    cache$ = paths;
    relative = cache$[0];
    absolute = cache$[1];
    templateCache = options.isPartial ? partials : templates;
    templateCache[relative] = {
      render: function () {
        if (!(options.cache === false))
          return readAndCompileSync(absolute);
        return function (viewObject) {
          return readAndCompileSync(absolute)(viewObject);
        };
      }()
    };
    return cb(null);
  };
  readAndCompileSync = function (absolutePath) {
    var template;
    template = readFileSync(absolutePath);
    return Handlebars.compile(template);
  };
  removeBaseDir = function (baseDir, path) {
    return path.split(new RegExp('^' + baseDir + Path.sep))[1];
  };
  stripPath = function (path) {
    var base, filename;
    filename = Path.basename(path);
    base = filename.split('.')[0];
    if (isPartial(base))
      base = base.split(/^_/)[1];
    return '' + path.split(filename)[0] + base;
  };
  isPartial = function (filename) {
    return null != filename.match(/^_/);
  };
  isAbsolutePath = function (path) {
    return null != path.match(new RegExp('^' + Path.sep));
  };
  readFileSync = function (path, options) {
    if (null == options)
      options = {};
    return fs.readFileSync(path, utils.defaults(options, { encoding: 'utf8' }));
  };
  utils = function () {
    var slice, toString;
    slice = Array.prototype.slice;
    toString = Object.prototype.toString;
    return {
      defaults: function (obj) {
        slice.call(arguments, 1).forEach(function (source) {
          var key;
          for (key in source) {
            if (!isOwn$(source, key))
              continue;
            if (!(null != obj[key]))
              obj[key] = source[key];
          }
          return void 0;
        });
        return obj;
      },
      isArray: Array.isArray,
      isObject: function (obj) {
        return obj === Object(obj);
      },
      isString: function (obj) {
        return toString.call(obj) === '[object String]';
      },
      isEmpty: function (obj) {
        var key;
        if (!(null != obj))
          return true;
        if (utils.isArray(obj) || utils.isString(obj))
          return obj.length === 0;
        for (key in obj) {
          if (!isOwn$(obj, key))
            continue;
          return false;
        }
        return true;
      }
    };
  }();
  function isOwn$(o, p) {
    return {}.hasOwnProperty.call(o, p);
  }
}.call(this);
