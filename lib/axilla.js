// Generated by CoffeeScript 2.0.0-beta5
void function () {
  var async, axilla, buildRenderFunction, cacheContents, cachePartial, cacheTemplate, compileFromDiskAndRender, fs, glob, Handlebars, isAbsolutePath, isPartial, partials, Path, readFile, readFileSync, removeBaseDir, render, renderPartial, stripPath, templates, utils;
  fs = require('fs');
  Path = require('path');
  glob = require('glob');
  async = require('async');
  Handlebars = require('handlebars');
  module.exports = axilla = function (basePath, defaults) {
    if (utils.isObject(basePath)) {
      defaults = basePath;
      basePath = null;
    }
    return function (path, viewObject, options) {
      if (!utils.isEmpty(basePath))
        path = Path.normalize('' + basePath + Path.sep + path);
      return render(path, viewObject, utils.defaults(options, defaults));
    };
  };
  axilla.templates = templates = {};
  axilla.partials = partials = {};
  Handlebars.registerHelper('partial', function (path) {
    return renderPartial(path, this);
  });
  axilla.render = render = function (path, viewObject) {
    var template;
    if (!(null != (template = templates[path])))
      throw new Error('Unable to resolve template at ' + path);
    return template.render(viewObject);
  };
  axilla.renderPartial = renderPartial = function (path, viewObject) {
    var partial;
    if (!(null != (partial = partials[path])))
      throw new Error('Unable to resolve partial at ' + path);
    return partial.render(viewObject);
  };
  axilla.cache = function (options, cb) {
    var baseDir;
    baseDir = utils.isString(options) ? options : options.baseDir;
    if (!isAbsolutePath(baseDir))
      baseDir = Path.normalize('' + __dirname + Path.sep + baseDir);
    glob(Path.normalize('' + baseDir + '/**/*.mustache'), function (err, paths) {
      var iterator;
      iterator = function (path, cb) {
        return cacheContents([
          path,
          removeBaseDir(baseDir, path)
        ], options, cb);
      };
      return async.each(paths, iterator, function (err) {
        if (null != cb)
          return cb(err);
        if (null != err)
          throw err;
      });
    });
    return null;
  };
  axilla.clearCache = function () {
    axilla.templates = templates = {};
    return axilla.partials = partials = {};
  };
  compileFromDiskAndRender = function (absolutePath, viewObject) {
    var template;
    template = readFileSync(absolutePath);
    return Handlebars.compile(template)(viewObject);
  };
  cacheContents = function (paths, options, cb) {
    var absolute, cache$, relative;
    cache$ = paths;
    absolute = cache$[0];
    relative = cache$[1];
    return readFile(absolute, function (err, contents) {
      var base, fn;
      if (null != err)
        return cb(err);
      base = stripPath(relative);
      options = [
        [
          base,
          absolute
        ],
        contents,
        options
      ];
      fn = isPartial(Path.basename(relative)) ? cachePartial : cacheTemplate;
      fn.apply(null, [].slice.call(options).concat());
      return cb();
    });
  };
  cacheTemplate = function (paths, template, options) {
    var absolute, cache$, relative;
    cache$ = paths;
    relative = cache$[0];
    absolute = cache$[1];
    return templates[relative] = { render: buildRenderFunction(absolute, template, options) };
  };
  cachePartial = function (paths, partial, options) {
    var absolute, cache$, relative;
    cache$ = paths;
    relative = cache$[0];
    absolute = cache$[1];
    return partials[relative] = { render: buildRenderFunction(absolute, partial, options) };
  };
  buildRenderFunction = function (absolutePath, template, options) {
    if (!(options.reload === true))
      return Handlebars.compile(template);
    return utils.partiallyApply(compileFromDiskAndRender, absolutePath);
  };
  removeBaseDir = function (baseDir, path) {
    return path.split(new RegExp('^' + baseDir + '/'))[1];
  };
  stripPath = function (path) {
    var base, filename;
    filename = Path.basename(path);
    base = filename.split('.')[0];
    if (isPartial(base))
      base = base.split(/^_/)[1];
    return '' + path.split(filename)[0] + base;
  };
  isPartial = function (filename) {
    return null != filename.match(/^_/);
  };
  isAbsolutePath = function (path) {
    return null != path.match(new RegExp('^' + Path.sep));
  };
  readFile = function (path, cb) {
    return fs.readFile(path, 'utf8', cb);
  };
  readFileSync = function (path, options) {
    if (null == options)
      options = {};
    return fs.readFileSync(path, utils.defaults(options, { encoding: 'utf8' }));
  };
  utils = function () {
    var slice, toString;
    slice = Array.prototype.slice;
    toString = Object.prototype.toString;
    return {
      partiallyApply: function (fn, args) {
        args = 2 <= arguments.length ? [].slice.call(arguments, 1) : [];
        return fn.bind.apply(fn, [null].concat([].slice.call(args)));
      },
      extend: function (obj) {
        slice.call(arguments, 1).forEach(function (source) {
          var key;
          for (key in source) {
            if (!isOwn$(source, key))
              continue;
            obj[key] = source[key];
          }
          return void 0;
        });
        return obj;
      },
      defaults: function (obj) {
        slice.call(arguments, 1).forEach(function (source) {
          var key;
          for (key in source) {
            if (!isOwn$(source, key))
              continue;
            if (!(null != obj[key]))
              obj[key] = source[key];
          }
          return void 0;
        });
        return obj;
      },
      isArray: Array.isArray,
      isObject: function (obj) {
        return obj === Object(obj);
      },
      isString: function (obj) {
        return toString.call(obj) === '[object String]';
      },
      isEmpty: function (obj) {
        var key;
        if (!(null != obj))
          return true;
        if (utils.isArray(obj) || utils.isString(obj))
          return obj.length === 0;
        for (key in obj) {
          if (!isOwn$(obj, key))
            continue;
          return false;
        }
        return true;
      }
    };
  }();
  function isOwn$(o, p) {
    return {}.hasOwnProperty.call(o, p);
  }
}.call(this);
