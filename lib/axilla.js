// Generated by CoffeeScript 2.0.0-beta5
void function () {
  var axilla, cacheTemplate, fs, getTemplateReference, glob, Handlebars, isAbsolutePath, isPartial, partials, Path, readAndCompileSync, readFileSync, removeBasePath, removeExtensions, removeUnderscore, render, renderPartial, templates, utils;
  fs = require('fs');
  Path = require('path');
  glob = require('glob');
  Handlebars = require('handlebars');
  templates = {};
  partials = {};
  module.exports = axilla = function (basePath, defaults) {
    if (utils.isObject(basePath)) {
      defaults = basePath;
      basePath = null;
    }
    return function (path, viewObject, options) {
      if (!utils.isEmpty(basePath))
        path = Path.normalize('' + basePath + Path.sep + path);
      return render(path, viewObject, utils.defaults(options, defaults));
    };
  };
  axilla.configure = function (path, options) {
    if (null == options)
      options = {};
    if (!isAbsolutePath(path))
      throw new Error('First argument must be an absolute path');
    if (!fs.existsSync(path))
      throw new Error('#{path} does not exist');
    return glob.sync(Path.normalize('' + path + '/**/*.mustache')).forEach(function (file) {
      var opts, relativePath;
      relativePath = getTemplateReference(file, path);
      opts = utils.clone(options);
      if (isPartial(Path.basename(file))) {
        opts.isPartial = true;
        relativePath = removeUnderscore(relativePath);
      }
      return cacheTemplate(file, utils.extend(opts, { as: relativePath }));
    });
  };
  axilla.render = render = function (path, viewObject) {
    var template;
    if (!(null != (template = templates[path])))
      throw new Error('Unable to resolve template at ' + path);
    return template.render(viewObject);
  };
  axilla.clearCache = function () {
    templates = {};
    return partials = {};
  };
  axilla.handlebars = function () {
    return Handlebars;
  };
  axilla.templates = function () {
    return {
      templates: templates,
      partials: partials
    };
  };
  renderPartial = function (path, viewObject) {
    var partial;
    if (!(null != (partial = partials[path])))
      throw new Error('Unable to resolve partial at ' + path);
    return partial.render(viewObject);
  };
  getTemplateReference = function (file, dirname) {
    return removeBasePath(dirname, removeExtensions(file));
  };
  cacheTemplate = function (path, options) {
    var templateCache;
    templateCache = options.isPartial ? partials : templates;
    templateCache[options.as] = {
      render: function () {
        if (!(options.cache === false))
          return readAndCompileSync(path);
        return function (viewObject) {
          return readAndCompileSync(path)(viewObject);
        };
      }()
    };
    return void 0;
  };
  readAndCompileSync = function (absolutePath) {
    var template;
    template = readFileSync(absolutePath);
    return Handlebars.compile(template);
  };
  removeBasePath = function (dirname, path) {
    return path.split(new RegExp('^' + dirname + Path.sep))[1];
  };
  removeExtensions = function (path) {
    var base, filename;
    filename = Path.basename(path);
    base = filename.split('.')[0];
    return '' + path.split(filename)[0] + base;
  };
  removeUnderscore = function (path) {
    var base, filename;
    filename = Path.basename(path);
    base = filename.split(/^_/)[1];
    return '' + path.split(filename)[0] + base;
  };
  isPartial = function (filename) {
    return null != filename.match(/^_/);
  };
  isAbsolutePath = function (path) {
    return null != path.match(new RegExp('^' + Path.sep));
  };
  readFileSync = function (path, options) {
    if (null == options)
      options = {};
    return fs.readFileSync(path, utils.defaults(options, { encoding: 'utf8' }));
  };
  utils = function () {
    var slice, toString;
    slice = Array.prototype.slice;
    toString = Object.prototype.toString;
    return {
      extend: function (obj) {
        slice.call(arguments, 1).forEach(function (source) {
          var key;
          for (key in source) {
            if (!isOwn$(source, key))
              continue;
            obj[key] = source[key];
          }
          return void 0;
        });
        return obj;
      },
      defaults: function (obj) {
        slice.call(arguments, 1).forEach(function (source) {
          var key;
          for (key in source) {
            if (!isOwn$(source, key))
              continue;
            if (!(null != obj[key]))
              obj[key] = source[key];
          }
          return void 0;
        });
        return obj;
      },
      clone: function (obj) {
        return utils.extend({}, obj);
      },
      isArray: Array.isArray,
      isObject: function (obj) {
        return obj === Object(obj);
      },
      isString: function (obj) {
        return toString.call(obj) === '[object String]';
      },
      isEmpty: function (obj) {
        var key;
        if (!(null != obj))
          return true;
        if (utils.isArray(obj) || utils.isString(obj))
          return obj.length === 0;
        for (key in obj) {
          if (!isOwn$(obj, key))
            continue;
          return false;
        }
        return true;
      }
    };
  }();
  Handlebars.registerHelper('partial', function (path) {
    return new Handlebars.SafeString(renderPartial(path, this));
  });
  function isOwn$(o, p) {
    return {}.hasOwnProperty.call(o, p);
  }
}.call(this);
